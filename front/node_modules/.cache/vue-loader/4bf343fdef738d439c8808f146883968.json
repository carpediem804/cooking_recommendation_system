{"remainingRequest":"C:\\Users\\Daehyun\\Desktop\\sex\\team_project\\front\\node_modules\\vue-loader\\lib\\index.js??vue-loader-options!C:\\Users\\Daehyun\\Desktop\\sex\\team_project\\front\\node_modules\\buefy\\src\\components\\table\\Table.vue?vue&type=script&lang=js&","dependencies":[{"path":"C:\\Users\\Daehyun\\Desktop\\sex\\team_project\\front\\node_modules\\buefy\\src\\components\\table\\Table.vue","mtime":1542387018000},{"path":"C:\\Users\\Daehyun\\Desktop\\sex\\team_project\\front\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1544630775545},{"path":"C:\\Users\\Daehyun\\Desktop\\sex\\team_project\\front\\node_modules\\babel-loader\\lib\\index.js","mtime":1544630775208},{"path":"C:\\Users\\Daehyun\\Desktop\\sex\\team_project\\front\\node_modules\\cache-loader\\dist\\cjs.js","mtime":1544630775545},{"path":"C:\\Users\\Daehyun\\Desktop\\sex\\team_project\\front\\node_modules\\vue-loader\\lib\\index.js","mtime":1544630784402}],"contextDependencies":[],"result":["//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n//\n\nimport { getValueByPath, indexOf } from '../../utils/helpers'\n\nimport Checkbox from '../checkbox/Checkbox'\nimport Icon from '../icon/Icon'\nimport Pagination from '../pagination/Pagination'\n\nimport TableMobileSort from './TableMobileSort'\nimport TableColumn from './TableColumn'\n\nexport default {\n    name: 'BTable',\n    components: {\n        [Checkbox.name]: Checkbox,\n        [Icon.name]: Icon,\n        [Pagination.name]: Pagination,\n        [TableMobileSort.name]: TableMobileSort,\n        [TableColumn.name]: TableColumn\n    },\n    props: {\n        data: {\n            type: Array,\n            default: () => []\n        },\n        columns: {\n            type: Array,\n            default: () => []\n        },\n        bordered: Boolean,\n        striped: Boolean,\n        narrowed: Boolean,\n        hoverable: Boolean,\n        loading: Boolean,\n        detailed: Boolean,\n        checkable: Boolean,\n        selected: Object,\n        focusable: Boolean,\n        customIsChecked: Function,\n        isRowCheckable: {\n            type: Function,\n            default: () => true\n        },\n        checkedRows: {\n            type: Array,\n            default: () => []\n        },\n        mobileCards: {\n            type: Boolean,\n            default: true\n        },\n        defaultSort: [String, Array],\n        defaultSortDirection: {\n            type: String,\n            default: 'asc'\n        },\n        paginated: Boolean,\n        currentPage: {\n            type: Number,\n            default: 1\n        },\n        perPage: {\n            type: [Number, String],\n            default: 20\n        },\n        paginationSimple: Boolean,\n        paginationSize: String,\n        backendSorting: Boolean,\n        rowClass: {\n            type: Function,\n            default: () => ''\n        },\n        openedDetailed: {\n            type: Array,\n            default: () => []\n        },\n        hasDetailedVisible: {\n            type: Function,\n            default: () => true\n        },\n        detailKey: {\n            type: String,\n            default: ''\n        },\n        backendPagination: Boolean,\n        total: {\n            type: [Number, String],\n            default: 0\n        },\n        iconPack: String\n    },\n    data() {\n        return {\n            getValueByPath,\n            newColumns: [...this.columns],\n            visibleDetailRows: this.openedDetailed,\n            newData: this.data,\n            newDataTotal: this.backendPagination ? this.total : this.data.length,\n            newCheckedRows: [...this.checkedRows],\n            newCurrentPage: this.currentPage,\n            currentSortColumn: {},\n            isAsc: true,\n            firstTimeSort: true, // Used by first time initSort\n            _isTable: true // Used by TableColumn\n        }\n    },\n    computed: {\n        tableClasses() {\n            return {\n                'is-bordered': this.bordered,\n                'is-striped': this.striped,\n                'is-narrow': this.narrowed,\n                'has-mobile-cards': this.mobileCards,\n                'is-hoverable': (\n                    (this.hoverable || this.focusable) &&\n                    this.visibleData.length\n                )\n            }\n        },\n\n        /**\n         * Splitted data based on the pagination.\n         */\n        visibleData() {\n            if (!this.paginated) return this.newData\n\n            const currentPage = this.newCurrentPage\n            const perPage = this.perPage\n\n            if (this.newData.length <= perPage) {\n                return this.newData\n            } else {\n                const start = (currentPage - 1) * perPage\n                const end = parseInt(start, 10) + parseInt(perPage, 10)\n                return this.newData.slice(start, end)\n            }\n        },\n\n        /**\n         * Check if all rows in the page are checked.\n         */\n        isAllChecked() {\n            const validVisibleData = this.visibleData.filter(\n                    (row) => this.isRowCheckable(row))\n            if (validVisibleData.length === 0) return false\n            const isAllChecked = validVisibleData.some((currentVisibleRow) => {\n                return indexOf(this.newCheckedRows, currentVisibleRow, this.customIsChecked) < 0\n            })\n            return !isAllChecked\n        },\n\n        /**\n         * Check if all rows in the page are checkable.\n         */\n        isAllUncheckable() {\n            const validVisibleData = this.visibleData.filter(\n                    (row) => this.isRowCheckable(row))\n            return validVisibleData.length === 0\n        },\n\n        /**\n         * Check if has any sortable column.\n         */\n        hasSortablenewColumns() {\n            return this.newColumns.some((column) => {\n                return column.sortable\n            })\n        },\n\n        /**\n         * Return total column count based if it's checkable or expanded\n         */\n        columnCount() {\n            let count = this.newColumns.length\n            count += this.checkable ? 1 : 0\n            count += this.detailed ? 1 : 0\n\n            return count\n        }\n    },\n    watch: {\n        /**\n         * When data prop change:\n         *   1. Update internal value.\n         *   2. Reset newColumns (thead), in case it's on a v-for loop.\n         *   3. Sort again if it's not backend-sort.\n         *   4. Set new total if it's not backend-paginated.\n         */\n        data(value) {\n            // Save newColumns before resetting\n            const newColumns = this.newColumns\n\n            this.newColumns = []\n            this.newData = value\n\n            // Prevent table from being headless, data could change and created hook\n            // on column might not trigger\n            this.$nextTick(() => {\n                if (!this.newColumns.length) this.newColumns = newColumns\n            })\n\n            if (!this.backendSorting) {\n                this.sort(this.currentSortColumn, true)\n            }\n            if (!this.backendPagination) {\n                this.newDataTotal = value.length\n            }\n        },\n\n        /**\n         * When Pagination total change, update internal total\n         * only if it's backend-paginated.\n         */\n        total(newTotal) {\n            if (!this.backendPagination) return\n\n            this.newDataTotal = newTotal\n        },\n\n        /**\n         * When checkedRows prop change, update internal value without\n         * mutating original data.\n         */\n        checkedRows(rows) {\n            this.newCheckedRows = [...rows]\n        },\n\n        columns(value) {\n            this.newColumns = [...value]\n        },\n\n        /**\n         * When newColumns change, call initSort only first time (For example async data).\n         */\n        newColumns(newColumns) {\n            if (newColumns.length && this.firstTimeSort) {\n                this.initSort()\n                this.firstTimeSort = false\n            } else if (newColumns.length) {\n                if (this.currentSortColumn.field) {\n                    for (let i = 0; i < newColumns.length; i++) {\n                        if (newColumns[i].field === this.currentSortColumn.field) {\n                            this.currentSortColumn = newColumns[i]\n                            break\n                        }\n                    }\n                }\n            }\n        },\n\n        /**\n        * When the user wants to control the detailed rows via props.\n        * Or wants to open the details of certain row with the router for example.\n        */\n        openedDetailed(expandedRows) {\n            this.visibleDetailRows = expandedRows\n        },\n\n        currentPage(newVal) {\n            this.newCurrentPage = newVal\n        }\n    },\n    methods: {\n        /**\n         * Sort an array by key without mutating original data.\n         * Call the user sort function if it was passed.\n         */\n        sortBy(array, key, fn, isAsc) {\n            let sorted = []\n            // Sorting without mutating original data\n            if (fn && typeof fn === 'function') {\n                sorted = [...array].sort((a, b) => fn(a, b, isAsc))\n            } else {\n                sorted = [...array].sort((a, b) => {\n                    // Get nested values from objects\n                    let newA = getValueByPath(a, key)\n                    let newB = getValueByPath(b, key)\n\n                    // sort boolean type\n                    if (typeof newA === 'boolean' && typeof newB === 'boolean') {\n                        return isAsc ? newA - newB : newB - newA\n                    }\n\n                    if (!newA && newA !== 0) return 1\n                    if (!newB && newB !== 0) return -1\n                    if (newA === newB) return 0\n\n                    newA = (typeof newA === 'string')\n                        ? newA.toUpperCase()\n                        : newA\n                    newB = (typeof newB === 'string')\n                        ? newB.toUpperCase()\n                        : newB\n\n                    return isAsc\n                        ? newA > newB ? 1 : -1\n                        : newA > newB ? -1 : 1\n                })\n            }\n\n            return sorted\n        },\n\n        /**\n         * Sort the column.\n         * Toggle current direction on column if it's sortable\n         * and not just updating the prop.\n         */\n        sort(column, updatingData = false) {\n            if (!column || !column.sortable) return\n\n            if (!updatingData) {\n                this.isAsc = column === this.currentSortColumn\n                    ? !this.isAsc\n                    : (this.defaultSortDirection.toLowerCase() !== 'desc')\n            }\n            if (!this.firstTimeSort) {\n                this.$emit('sort', column.field, this.isAsc ? 'asc' : 'desc')\n            }\n            if (!this.backendSorting) {\n                this.newData = this.sortBy(\n                    this.newData,\n                    column.field,\n                    column.customSort,\n                    this.isAsc\n                )\n            }\n            this.currentSortColumn = column\n        },\n\n        /**\n         * Check if the row is checked (is added to the array).\n         */\n        isRowChecked(row) {\n            return indexOf(this.newCheckedRows, row, this.customIsChecked) >= 0\n        },\n\n        /**\n         * Remove a checked row from the array.\n         */\n        removeCheckedRow(row) {\n            const index = indexOf(this.newCheckedRows, row, this.customIsChecked)\n            if (index >= 0) {\n                this.newCheckedRows.splice(index, 1)\n            }\n        },\n\n        /**\n         * Header checkbox click listener.\n         * Add or remove all rows in current page.\n         */\n        checkAll() {\n            const isAllChecked = this.isAllChecked\n            this.visibleData.forEach((currentRow) => {\n                this.removeCheckedRow(currentRow)\n                if (!isAllChecked) {\n                    if (this.isRowCheckable(currentRow)) {\n                        this.newCheckedRows.push(currentRow)\n                    }\n                }\n            })\n\n            this.$emit('check', this.newCheckedRows)\n            this.$emit('check-all', this.newCheckedRows)\n\n            // Emit checked rows to update user variable\n            this.$emit('update:checkedRows', this.newCheckedRows)\n        },\n\n        /**\n         * Row checkbox click listener.\n         * Add or remove a single row.\n         */\n        checkRow(row) {\n            if (!this.isRowChecked(row)) {\n                this.newCheckedRows.push(row)\n            } else {\n                this.removeCheckedRow(row)\n            }\n\n            this.$emit('check', this.newCheckedRows, row)\n\n            // Emit checked rows to update user variable\n            this.$emit('update:checkedRows', this.newCheckedRows)\n        },\n\n        /**\n         * Row click listener.\n         * Emit all necessary events.\n         */\n        selectRow(row, index) {\n            this.$emit('click', row)\n\n            if (this.selected === row) return\n\n            // Emit new and old row\n            this.$emit('select', row, this.selected)\n\n            // Emit new row to update user variable\n            this.$emit('update:selected', row)\n        },\n\n        /**\n         * Paginator change listener.\n         */\n        pageChanged(page) {\n            this.newCurrentPage = page > 0 ? page : 1\n            this.$emit('page-change', this.newCurrentPage)\n            this.$emit('update:currentPage', this.newCurrentPage)\n        },\n\n        /**\n         * Toggle to show/hide details slot\n         */\n        toggleDetails(obj) {\n            const found = this.isVisibleDetailRow(obj)\n\n            if (found) {\n                this.closeDetailRow(obj)\n                this.$emit('details-close', obj)\n            } else {\n                this.openDetailRow(obj)\n                this.$emit('details-open', obj)\n            }\n\n            // Syncs the detailed rows with the parent component\n            this.$emit('update:openedDetailed', this.visibleDetailRows)\n        },\n\n        openDetailRow(obj) {\n            const index = this.handleDetailKey(obj)\n            this.visibleDetailRows.push(index)\n        },\n\n        closeDetailRow(obj) {\n            const index = this.handleDetailKey(obj)\n            const i = this.visibleDetailRows.indexOf(index)\n            this.visibleDetailRows.splice(i, 1)\n        },\n\n        isVisibleDetailRow(obj) {\n            const index = this.handleDetailKey(obj)\n            const result = this.visibleDetailRows.indexOf(index) >= 0\n            return result\n        },\n\n        /**\n        * When the detailKey is defined we use the object[detailKey] as index.\n        * If not, use the object reference by default.\n        */\n        handleDetailKey(index) {\n            const key = this.detailKey\n            return !key.length\n                ? index\n                : index[key]\n        },\n\n        checkPredefinedDetailedRows() {\n            const defaultExpandedRowsDefined = this.openedDetailed.length > 0\n            if (defaultExpandedRowsDefined && !this.detailKey.length) {\n                throw new Error('If you set a predefined opened-detailed, you must provide a unique key using the prop \"detail-key\"')\n            }\n        },\n\n        /**\n         * Check if footer slot has custom content.\n         */\n        hasCustomFooterSlot() {\n            if (this.$slots.footer.length > 1) return true\n\n            const tag = this.$slots.footer[0].tag\n            if (tag !== 'th' && tag !== 'td') return false\n\n            return true\n        },\n\n        /**\n         * Check if bottom-left slot exists.\n         */\n        hasBottomLeftSlot() {\n            return typeof this.$slots['bottom-left'] !== 'undefined'\n        },\n\n        /**\n         * Table arrow keys listener, change selection.\n         */\n        pressedArrow(pos) {\n            if (!this.visibleData.length) return\n\n            let index = this.visibleData.indexOf(this.selected) + pos\n\n            // Prevent from going up from first and down from last\n            index = index < 0\n                ? 0\n                : index > this.visibleData.length - 1\n                    ? this.visibleData.length - 1\n                    : index\n\n            this.selectRow(this.visibleData[index])\n        },\n\n        /**\n         * Focus table element if has selected prop.\n         */\n        focus() {\n            if (!this.focusable) return\n\n            this.$el.querySelector('table').focus()\n        },\n\n        /**\n         * Initial sorted column based on the default-sort prop.\n         */\n        initSort() {\n            if (!this.defaultSort) return\n\n            let sortField = ''\n            let sortDirection = this.defaultSortDirection\n\n            if (Array.isArray(this.defaultSort)) {\n                sortField = this.defaultSort[0]\n                if (this.defaultSort[1]) {\n                    sortDirection = this.defaultSort[1]\n                }\n            } else {\n                sortField = this.defaultSort\n            }\n\n            this.newColumns.forEach((column) => {\n                if (column.field === sortField) {\n                    this.isAsc = sortDirection.toLowerCase() !== 'desc'\n                    this.sort(column, true)\n                }\n            })\n        }\n    },\n\n    mounted() {\n        this.checkPredefinedDetailedRows()\n    }\n}\n",{"version":3,"sources":["Table.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8KA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA","file":"Table.vue","sourceRoot":"node_modules\\buefy\\src\\components\\table","sourcesContent":["<template>\r\n    <div class=\"b-table\" :class=\"{ 'is-loading': loading }\">\r\n        <b-table-mobile-sort\r\n            v-if=\"mobileCards && hasSortablenewColumns\"\r\n            :current-sort-column=\"currentSortColumn\"\r\n            :is-asc=\"isAsc\"\r\n            :columns=\"newColumns\"\r\n            @sort=\"(column) => sort(column)\"\r\n        />\r\n\r\n        <div class=\"table-wrapper\">\r\n            <table\r\n                class=\"table\"\r\n                :class=\"tableClasses\"\r\n                :tabindex=\"!focusable ? false : 0\"\r\n                @keydown.prevent.up=\"pressedArrow(-1)\"\r\n                @keydown.prevent.down=\"pressedArrow(1)\">\r\n                <thead v-if=\"newColumns.length\">\r\n                    <tr>\r\n                        <th v-if=\"detailed\" width=\"40px\"/>\r\n                        <th class=\"checkbox-cell\" v-if=\"checkable\">\r\n                            <b-checkbox\r\n                                :value=\"isAllChecked\"\r\n                                :disabled=\"isAllUncheckable\"\r\n                                @change.native=\"checkAll\"/>\r\n                        </th>\r\n                        <th\r\n                            v-for=\"(column, index) in newColumns\"\r\n                            v-if=\"column.visible || column.visible === undefined\"\r\n                            :key=\"index\"\r\n                            :class=\"{\r\n                                'is-current-sort': currentSortColumn === column,\r\n                                'is-sortable': column.sortable\r\n                            }\"\r\n                            :style=\"{ width: column.width + 'px' }\"\r\n                            @click.stop=\"sort(column)\">\r\n                            <div\r\n                                class=\"th-wrap\"\r\n                                :class=\"{\r\n                                    'is-numeric': column.numeric,\r\n                                    'is-centered': column.centered\r\n                            }\">\r\n                                <slot\r\n                                    v-if=\"$scopedSlots.header\"\r\n                                    name=\"header\"\r\n                                    :column=\"column\"\r\n                                    :index=\"index\"\r\n                                />\r\n                                <template v-else>{{ column.label }}</template>\r\n\r\n                                <b-icon\r\n                                    v-show=\"currentSortColumn === column\"\r\n                                    icon=\"arrow-up\"\r\n                                    :pack=\"iconPack\"\r\n                                    both\r\n                                    size=\"is-small\"\r\n                                    :class=\"{ 'is-desc': !isAsc }\"/>\r\n                            </div>\r\n                        </th>\r\n                    </tr>\r\n                </thead>\r\n                <tbody v-if=\"visibleData.length\">\r\n                    <template v-for=\"(row, index) in visibleData\">\r\n                        <tr\r\n                            :key=\"index\"\r\n                            :class=\"[rowClass(row, index), {\r\n                                'is-selected': row === selected,\r\n                                'is-checked': isRowChecked(row)\r\n                            }]\"\r\n                            @click=\"selectRow(row)\"\r\n                            @dblclick=\"$emit('dblclick', row)\">\r\n\r\n                            <td\r\n                                v-if=\"detailed\"\r\n                                class=\"chevron-cell\"\r\n                            >\r\n                                <a\r\n                                    v-if=\"hasDetailedVisible(row)\"\r\n                                    role=\"button\"\r\n                                    @click.stop=\"toggleDetails(row)\">\r\n                                    <b-icon\r\n                                        icon=\"chevron-right\"\r\n                                        :pack=\"iconPack\"\r\n                                        both\r\n                                        :class=\"{'is-expanded': isVisibleDetailRow(row)}\"/>\r\n                                </a>\r\n                            </td>\r\n\r\n                            <td class=\"checkbox-cell\" v-if=\"checkable\">\r\n                                <b-checkbox\r\n                                    :disabled=\"!isRowCheckable(row)\"\r\n                                    :value=\"isRowChecked(row)\"\r\n                                    @change.native=\"checkRow(row)\"\r\n                                />\r\n                            </td>\r\n\r\n                            <slot\r\n                                v-if=\"$scopedSlots.default\"\r\n                                :row=\"row\"\r\n                                :index=\"index\"\r\n                            />\r\n                            <template v-else>\r\n                                <BTableColumn\r\n                                    v-for=\"column in newColumns\"\r\n                                    v-bind=\"column\"\r\n                                    :key=\"column.field\"\r\n                                    internal>\r\n                                    <span\r\n                                        v-if=\"column.renderHtml\"\r\n                                        v-html=\"getValueByPath(row, column.field)\"\r\n                                    />\r\n                                    <template v-else>\r\n                                        {{ getValueByPath(row, column.field) }}\r\n                                    </template>\r\n                                </BTableColumn>\r\n                            </template>\r\n                        </tr>\r\n\r\n                        <!-- Do not add `key` here (breaks details) -->\r\n                        <!-- eslint-disable-next-line -->\r\n                        <tr\r\n                            v-if=\"detailed && isVisibleDetailRow(row)\"\r\n                            class=\"detail\">\r\n                            <td :colspan=\"columnCount\">\r\n                                <div class=\"detail-container\">\r\n                                    <slot\r\n                                        name=\"detail\"\r\n                                        :row=\"row\"\r\n                                        :index=\"index\"/>\r\n                                </div>\r\n                            </td>\r\n                        </tr>\r\n                    </template>\r\n                </tbody>\r\n                <tbody v-else>\r\n                    <tr class=\"is-empty\">\r\n                        <td :colspan=\"columnCount\">\r\n                            <slot name=\"empty\"/>\r\n                        </td>\r\n                    </tr>\r\n                </tbody>\r\n                <tfoot v-if=\"$slots.footer !== undefined\">\r\n                    <tr class=\"table-footer\">\r\n                        <slot name=\"footer\" v-if=\"hasCustomFooterSlot()\"/>\r\n                        <th :colspan=\"columnCount\" v-else>\r\n                            <slot name=\"footer\"/>\r\n                        </th>\r\n                    </tr>\r\n                </tfoot>\r\n            </table>\r\n        </div>\r\n\r\n        <div v-if=\"(checkable && hasBottomLeftSlot()) || paginated\" class=\"level\">\r\n            <div class=\"level-left\">\r\n                <slot name=\"bottom-left\"/>\r\n            </div>\r\n\r\n            <div class=\"level-right\">\r\n                <div v-if=\"paginated\" class=\"level-item\">\r\n                    <b-pagination\r\n                        :icon-pack=\"iconPack\"\r\n                        :total=\"newDataTotal\"\r\n                        :per-page=\"perPage\"\r\n                        :simple=\"paginationSimple\"\r\n                        :size=\"paginationSize\"\r\n                        :current=\"newCurrentPage\"\r\n                        @change=\"pageChanged\"/>\r\n                </div>\r\n            </div>\r\n        </div>\r\n    </div>\r\n</template>\r\n\r\n<script>\r\n    import { getValueByPath, indexOf } from '../../utils/helpers'\r\n\r\n    import Checkbox from '../checkbox/Checkbox'\r\n    import Icon from '../icon/Icon'\r\n    import Pagination from '../pagination/Pagination'\r\n\r\n    import TableMobileSort from './TableMobileSort'\r\n    import TableColumn from './TableColumn'\r\n\r\n    export default {\r\n        name: 'BTable',\r\n        components: {\r\n            [Checkbox.name]: Checkbox,\r\n            [Icon.name]: Icon,\r\n            [Pagination.name]: Pagination,\r\n            [TableMobileSort.name]: TableMobileSort,\r\n            [TableColumn.name]: TableColumn\r\n        },\r\n        props: {\r\n            data: {\r\n                type: Array,\r\n                default: () => []\r\n            },\r\n            columns: {\r\n                type: Array,\r\n                default: () => []\r\n            },\r\n            bordered: Boolean,\r\n            striped: Boolean,\r\n            narrowed: Boolean,\r\n            hoverable: Boolean,\r\n            loading: Boolean,\r\n            detailed: Boolean,\r\n            checkable: Boolean,\r\n            selected: Object,\r\n            focusable: Boolean,\r\n            customIsChecked: Function,\r\n            isRowCheckable: {\r\n                type: Function,\r\n                default: () => true\r\n            },\r\n            checkedRows: {\r\n                type: Array,\r\n                default: () => []\r\n            },\r\n            mobileCards: {\r\n                type: Boolean,\r\n                default: true\r\n            },\r\n            defaultSort: [String, Array],\r\n            defaultSortDirection: {\r\n                type: String,\r\n                default: 'asc'\r\n            },\r\n            paginated: Boolean,\r\n            currentPage: {\r\n                type: Number,\r\n                default: 1\r\n            },\r\n            perPage: {\r\n                type: [Number, String],\r\n                default: 20\r\n            },\r\n            paginationSimple: Boolean,\r\n            paginationSize: String,\r\n            backendSorting: Boolean,\r\n            rowClass: {\r\n                type: Function,\r\n                default: () => ''\r\n            },\r\n            openedDetailed: {\r\n                type: Array,\r\n                default: () => []\r\n            },\r\n            hasDetailedVisible: {\r\n                type: Function,\r\n                default: () => true\r\n            },\r\n            detailKey: {\r\n                type: String,\r\n                default: ''\r\n            },\r\n            backendPagination: Boolean,\r\n            total: {\r\n                type: [Number, String],\r\n                default: 0\r\n            },\r\n            iconPack: String\r\n        },\r\n        data() {\r\n            return {\r\n                getValueByPath,\r\n                newColumns: [...this.columns],\r\n                visibleDetailRows: this.openedDetailed,\r\n                newData: this.data,\r\n                newDataTotal: this.backendPagination ? this.total : this.data.length,\r\n                newCheckedRows: [...this.checkedRows],\r\n                newCurrentPage: this.currentPage,\r\n                currentSortColumn: {},\r\n                isAsc: true,\r\n                firstTimeSort: true, // Used by first time initSort\r\n                _isTable: true // Used by TableColumn\r\n            }\r\n        },\r\n        computed: {\r\n            tableClasses() {\r\n                return {\r\n                    'is-bordered': this.bordered,\r\n                    'is-striped': this.striped,\r\n                    'is-narrow': this.narrowed,\r\n                    'has-mobile-cards': this.mobileCards,\r\n                    'is-hoverable': (\r\n                        (this.hoverable || this.focusable) &&\r\n                        this.visibleData.length\r\n                    )\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Splitted data based on the pagination.\r\n             */\r\n            visibleData() {\r\n                if (!this.paginated) return this.newData\r\n\r\n                const currentPage = this.newCurrentPage\r\n                const perPage = this.perPage\r\n\r\n                if (this.newData.length <= perPage) {\r\n                    return this.newData\r\n                } else {\r\n                    const start = (currentPage - 1) * perPage\r\n                    const end = parseInt(start, 10) + parseInt(perPage, 10)\r\n                    return this.newData.slice(start, end)\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Check if all rows in the page are checked.\r\n             */\r\n            isAllChecked() {\r\n                const validVisibleData = this.visibleData.filter(\r\n                        (row) => this.isRowCheckable(row))\r\n                if (validVisibleData.length === 0) return false\r\n                const isAllChecked = validVisibleData.some((currentVisibleRow) => {\r\n                    return indexOf(this.newCheckedRows, currentVisibleRow, this.customIsChecked) < 0\r\n                })\r\n                return !isAllChecked\r\n            },\r\n\r\n            /**\r\n             * Check if all rows in the page are checkable.\r\n             */\r\n            isAllUncheckable() {\r\n                const validVisibleData = this.visibleData.filter(\r\n                        (row) => this.isRowCheckable(row))\r\n                return validVisibleData.length === 0\r\n            },\r\n\r\n            /**\r\n             * Check if has any sortable column.\r\n             */\r\n            hasSortablenewColumns() {\r\n                return this.newColumns.some((column) => {\r\n                    return column.sortable\r\n                })\r\n            },\r\n\r\n            /**\r\n             * Return total column count based if it's checkable or expanded\r\n             */\r\n            columnCount() {\r\n                let count = this.newColumns.length\r\n                count += this.checkable ? 1 : 0\r\n                count += this.detailed ? 1 : 0\r\n\r\n                return count\r\n            }\r\n        },\r\n        watch: {\r\n            /**\r\n             * When data prop change:\r\n             *   1. Update internal value.\r\n             *   2. Reset newColumns (thead), in case it's on a v-for loop.\r\n             *   3. Sort again if it's not backend-sort.\r\n             *   4. Set new total if it's not backend-paginated.\r\n             */\r\n            data(value) {\r\n                // Save newColumns before resetting\r\n                const newColumns = this.newColumns\r\n\r\n                this.newColumns = []\r\n                this.newData = value\r\n\r\n                // Prevent table from being headless, data could change and created hook\r\n                // on column might not trigger\r\n                this.$nextTick(() => {\r\n                    if (!this.newColumns.length) this.newColumns = newColumns\r\n                })\r\n\r\n                if (!this.backendSorting) {\r\n                    this.sort(this.currentSortColumn, true)\r\n                }\r\n                if (!this.backendPagination) {\r\n                    this.newDataTotal = value.length\r\n                }\r\n            },\r\n\r\n            /**\r\n             * When Pagination total change, update internal total\r\n             * only if it's backend-paginated.\r\n             */\r\n            total(newTotal) {\r\n                if (!this.backendPagination) return\r\n\r\n                this.newDataTotal = newTotal\r\n            },\r\n\r\n            /**\r\n             * When checkedRows prop change, update internal value without\r\n             * mutating original data.\r\n             */\r\n            checkedRows(rows) {\r\n                this.newCheckedRows = [...rows]\r\n            },\r\n\r\n            columns(value) {\r\n                this.newColumns = [...value]\r\n            },\r\n\r\n            /**\r\n             * When newColumns change, call initSort only first time (For example async data).\r\n             */\r\n            newColumns(newColumns) {\r\n                if (newColumns.length && this.firstTimeSort) {\r\n                    this.initSort()\r\n                    this.firstTimeSort = false\r\n                } else if (newColumns.length) {\r\n                    if (this.currentSortColumn.field) {\r\n                        for (let i = 0; i < newColumns.length; i++) {\r\n                            if (newColumns[i].field === this.currentSortColumn.field) {\r\n                                this.currentSortColumn = newColumns[i]\r\n                                break\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            },\r\n\r\n            /**\r\n            * When the user wants to control the detailed rows via props.\r\n            * Or wants to open the details of certain row with the router for example.\r\n            */\r\n            openedDetailed(expandedRows) {\r\n                this.visibleDetailRows = expandedRows\r\n            },\r\n\r\n            currentPage(newVal) {\r\n                this.newCurrentPage = newVal\r\n            }\r\n        },\r\n        methods: {\r\n            /**\r\n             * Sort an array by key without mutating original data.\r\n             * Call the user sort function if it was passed.\r\n             */\r\n            sortBy(array, key, fn, isAsc) {\r\n                let sorted = []\r\n                // Sorting without mutating original data\r\n                if (fn && typeof fn === 'function') {\r\n                    sorted = [...array].sort((a, b) => fn(a, b, isAsc))\r\n                } else {\r\n                    sorted = [...array].sort((a, b) => {\r\n                        // Get nested values from objects\r\n                        let newA = getValueByPath(a, key)\r\n                        let newB = getValueByPath(b, key)\r\n\r\n                        // sort boolean type\r\n                        if (typeof newA === 'boolean' && typeof newB === 'boolean') {\r\n                            return isAsc ? newA - newB : newB - newA\r\n                        }\r\n\r\n                        if (!newA && newA !== 0) return 1\r\n                        if (!newB && newB !== 0) return -1\r\n                        if (newA === newB) return 0\r\n\r\n                        newA = (typeof newA === 'string')\r\n                            ? newA.toUpperCase()\r\n                            : newA\r\n                        newB = (typeof newB === 'string')\r\n                            ? newB.toUpperCase()\r\n                            : newB\r\n\r\n                        return isAsc\r\n                            ? newA > newB ? 1 : -1\r\n                            : newA > newB ? -1 : 1\r\n                    })\r\n                }\r\n\r\n                return sorted\r\n            },\r\n\r\n            /**\r\n             * Sort the column.\r\n             * Toggle current direction on column if it's sortable\r\n             * and not just updating the prop.\r\n             */\r\n            sort(column, updatingData = false) {\r\n                if (!column || !column.sortable) return\r\n\r\n                if (!updatingData) {\r\n                    this.isAsc = column === this.currentSortColumn\r\n                        ? !this.isAsc\r\n                        : (this.defaultSortDirection.toLowerCase() !== 'desc')\r\n                }\r\n                if (!this.firstTimeSort) {\r\n                    this.$emit('sort', column.field, this.isAsc ? 'asc' : 'desc')\r\n                }\r\n                if (!this.backendSorting) {\r\n                    this.newData = this.sortBy(\r\n                        this.newData,\r\n                        column.field,\r\n                        column.customSort,\r\n                        this.isAsc\r\n                    )\r\n                }\r\n                this.currentSortColumn = column\r\n            },\r\n\r\n            /**\r\n             * Check if the row is checked (is added to the array).\r\n             */\r\n            isRowChecked(row) {\r\n                return indexOf(this.newCheckedRows, row, this.customIsChecked) >= 0\r\n            },\r\n\r\n            /**\r\n             * Remove a checked row from the array.\r\n             */\r\n            removeCheckedRow(row) {\r\n                const index = indexOf(this.newCheckedRows, row, this.customIsChecked)\r\n                if (index >= 0) {\r\n                    this.newCheckedRows.splice(index, 1)\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Header checkbox click listener.\r\n             * Add or remove all rows in current page.\r\n             */\r\n            checkAll() {\r\n                const isAllChecked = this.isAllChecked\r\n                this.visibleData.forEach((currentRow) => {\r\n                    this.removeCheckedRow(currentRow)\r\n                    if (!isAllChecked) {\r\n                        if (this.isRowCheckable(currentRow)) {\r\n                            this.newCheckedRows.push(currentRow)\r\n                        }\r\n                    }\r\n                })\r\n\r\n                this.$emit('check', this.newCheckedRows)\r\n                this.$emit('check-all', this.newCheckedRows)\r\n\r\n                // Emit checked rows to update user variable\r\n                this.$emit('update:checkedRows', this.newCheckedRows)\r\n            },\r\n\r\n            /**\r\n             * Row checkbox click listener.\r\n             * Add or remove a single row.\r\n             */\r\n            checkRow(row) {\r\n                if (!this.isRowChecked(row)) {\r\n                    this.newCheckedRows.push(row)\r\n                } else {\r\n                    this.removeCheckedRow(row)\r\n                }\r\n\r\n                this.$emit('check', this.newCheckedRows, row)\r\n\r\n                // Emit checked rows to update user variable\r\n                this.$emit('update:checkedRows', this.newCheckedRows)\r\n            },\r\n\r\n            /**\r\n             * Row click listener.\r\n             * Emit all necessary events.\r\n             */\r\n            selectRow(row, index) {\r\n                this.$emit('click', row)\r\n\r\n                if (this.selected === row) return\r\n\r\n                // Emit new and old row\r\n                this.$emit('select', row, this.selected)\r\n\r\n                // Emit new row to update user variable\r\n                this.$emit('update:selected', row)\r\n            },\r\n\r\n            /**\r\n             * Paginator change listener.\r\n             */\r\n            pageChanged(page) {\r\n                this.newCurrentPage = page > 0 ? page : 1\r\n                this.$emit('page-change', this.newCurrentPage)\r\n                this.$emit('update:currentPage', this.newCurrentPage)\r\n            },\r\n\r\n            /**\r\n             * Toggle to show/hide details slot\r\n             */\r\n            toggleDetails(obj) {\r\n                const found = this.isVisibleDetailRow(obj)\r\n\r\n                if (found) {\r\n                    this.closeDetailRow(obj)\r\n                    this.$emit('details-close', obj)\r\n                } else {\r\n                    this.openDetailRow(obj)\r\n                    this.$emit('details-open', obj)\r\n                }\r\n\r\n                // Syncs the detailed rows with the parent component\r\n                this.$emit('update:openedDetailed', this.visibleDetailRows)\r\n            },\r\n\r\n            openDetailRow(obj) {\r\n                const index = this.handleDetailKey(obj)\r\n                this.visibleDetailRows.push(index)\r\n            },\r\n\r\n            closeDetailRow(obj) {\r\n                const index = this.handleDetailKey(obj)\r\n                const i = this.visibleDetailRows.indexOf(index)\r\n                this.visibleDetailRows.splice(i, 1)\r\n            },\r\n\r\n            isVisibleDetailRow(obj) {\r\n                const index = this.handleDetailKey(obj)\r\n                const result = this.visibleDetailRows.indexOf(index) >= 0\r\n                return result\r\n            },\r\n\r\n            /**\r\n            * When the detailKey is defined we use the object[detailKey] as index.\r\n            * If not, use the object reference by default.\r\n            */\r\n            handleDetailKey(index) {\r\n                const key = this.detailKey\r\n                return !key.length\r\n                    ? index\r\n                    : index[key]\r\n            },\r\n\r\n            checkPredefinedDetailedRows() {\r\n                const defaultExpandedRowsDefined = this.openedDetailed.length > 0\r\n                if (defaultExpandedRowsDefined && !this.detailKey.length) {\r\n                    throw new Error('If you set a predefined opened-detailed, you must provide a unique key using the prop \"detail-key\"')\r\n                }\r\n            },\r\n\r\n            /**\r\n             * Check if footer slot has custom content.\r\n             */\r\n            hasCustomFooterSlot() {\r\n                if (this.$slots.footer.length > 1) return true\r\n\r\n                const tag = this.$slots.footer[0].tag\r\n                if (tag !== 'th' && tag !== 'td') return false\r\n\r\n                return true\r\n            },\r\n\r\n            /**\r\n             * Check if bottom-left slot exists.\r\n             */\r\n            hasBottomLeftSlot() {\r\n                return typeof this.$slots['bottom-left'] !== 'undefined'\r\n            },\r\n\r\n            /**\r\n             * Table arrow keys listener, change selection.\r\n             */\r\n            pressedArrow(pos) {\r\n                if (!this.visibleData.length) return\r\n\r\n                let index = this.visibleData.indexOf(this.selected) + pos\r\n\r\n                // Prevent from going up from first and down from last\r\n                index = index < 0\r\n                    ? 0\r\n                    : index > this.visibleData.length - 1\r\n                        ? this.visibleData.length - 1\r\n                        : index\r\n\r\n                this.selectRow(this.visibleData[index])\r\n            },\r\n\r\n            /**\r\n             * Focus table element if has selected prop.\r\n             */\r\n            focus() {\r\n                if (!this.focusable) return\r\n\r\n                this.$el.querySelector('table').focus()\r\n            },\r\n\r\n            /**\r\n             * Initial sorted column based on the default-sort prop.\r\n             */\r\n            initSort() {\r\n                if (!this.defaultSort) return\r\n\r\n                let sortField = ''\r\n                let sortDirection = this.defaultSortDirection\r\n\r\n                if (Array.isArray(this.defaultSort)) {\r\n                    sortField = this.defaultSort[0]\r\n                    if (this.defaultSort[1]) {\r\n                        sortDirection = this.defaultSort[1]\r\n                    }\r\n                } else {\r\n                    sortField = this.defaultSort\r\n                }\r\n\r\n                this.newColumns.forEach((column) => {\r\n                    if (column.field === sortField) {\r\n                        this.isAsc = sortDirection.toLowerCase() !== 'desc'\r\n                        this.sort(column, true)\r\n                    }\r\n                })\r\n            }\r\n        },\r\n\r\n        mounted() {\r\n            this.checkPredefinedDetailedRows()\r\n        }\r\n    }\r\n</script>\r\n"]}]}